1 CONSTSYM const
2 INTSYM int
3 ID constInt1
4 ASSIGN =
5 PLUS +
6 UNSIGNEDINT 7
7 COMMA ,
8 ID constInt2
9 ASSIGN =
10 MINUS -
11 UNSIGNEDINT 17
12 COMMA ,
13 ID constInt3
14 ASSIGN =
15 UNSIGNEDINT 10
16 SEMICOLON ;
17 CONSTSYM const
18 CHARSYM char
19 ID constChar1
20 ASSIGN =
21 QUOTE '
22 CHAR a
23 QUOTE '
24 COMMA ,
25 ID constChar2
26 ASSIGN =
27 QUOTE '
28 CHAR -
29 QUOTE '
30 COMMA ,
31 ID constChar3
32 ASSIGN =
33 QUOTE '
34 CHAR /
35 QUOTE '
36 SEMICOLON ;
37 INTSYM int
38 ID variableInt1
39 COMMA ,
40 ID variableInt2
41 COMMA ,
42 ID variableIntArray
43 LBRACK [
44 UNSIGNEDINT 10
45 RBRACK ]
46 SEMICOLON ;
47 CHARSYM char
48 ID variableChar1
49 COMMA ,
50 ID variableCharArray
51 LBRACK [
52 UNSIGNEDINT 1
53 RBRACK ]
54 SEMICOLON ;
55 INTSYM int
56 ID funcReturnInt
57 LPARENT (
58 INTSYM int
59 ID a
60 COMMA ,
61 INTSYM int
62 ID b
63 RPARENT )
64 LBRACE {
65 INTSYM int
66 ID c
67 SEMICOLON ;
68 ID c
69 ASSIGN =
70 MINUS -
71 ID a
72 PLUS +
73 ID b
74 PLUS +
75 UNSIGNEDINT 1
76 MULTI *
77 UNSIGNEDINT 2
78 SEMICOLON ;
79 RETURNSYM return
80 LPARENT (
81 ID c
82 RPARENT )
83 SEMICOLON ;
84 RBRACE }
85 CHARSYM char
86 ID funcReturnChar
87 LPARENT (
88 CHARSYM char
89 ID c
90 RPARENT )
91 LBRACE {
92 CHARSYM char
93 ID d
94 SEMICOLON ;
95 ID d
96 ASSIGN =
97 ID c
98 SEMICOLON ;
99 RETURNSYM return
100 LPARENT (
101 ID d
102 RPARENT )
103 SEMICOLON ;
104 RBRACE }
105 VOIDSYM void
106 ID funcRelation
107 LPARENT (
108 INTSYM int
109 ID n
110 RPARENT )
111 LBRACE {
112 IFSYM if
113 LPARENT (
114 ID n
115 GREAT >
116 UNSIGNEDINT 0
117 RPARENT )
118 LBRACE {
119 IFSYM if
120 LPARENT (
121 ID n
122 LESS <
123 UNSIGNEDINT 7
124 RPARENT )
125 LBRACE {
126 PRINTFSYM printf
127 LPARENT (
128 DOUQUOTE "
129 STRING <
130 DOUQUOTE "
131 RPARENT )
132 SEMICOLON ;
133 RETURNSYM return
134 SEMICOLON ;
135 RBRACE }
136 IFSYM if
137 LPARENT (
138 ID n
139 LESSEQU <=
140 UNSIGNEDINT 7
141 RPARENT )
142 LBRACE {
143 PRINTFSYM printf
144 LPARENT (
145 DOUQUOTE "
146 STRING <=
147 DOUQUOTE "
148 RPARENT )
149 SEMICOLON ;
150 RETURNSYM return
151 SEMICOLON ;
152 RBRACE }
153 IFSYM if
154 LPARENT (
155 ID n
156 EQUAL ==
157 UNSIGNEDINT 17
158 RPARENT )
159 LBRACE {
160 PRINTFSYM printf
161 LPARENT (
162 DOUQUOTE "
163 STRING ==
164 DOUQUOTE "
165 RPARENT )
166 SEMICOLON ;
167 RETURNSYM return
168 SEMICOLON ;
169 RBRACE }
170 IFSYM if
171 LPARENT (
172 ID n
173 GREATEQU >=
174 UNSIGNEDINT 77
175 RPARENT )
176 LBRACE {
177 PRINTFSYM printf
178 LPARENT (
179 DOUQUOTE "
180 STRING >=
181 DOUQUOTE "
182 RPARENT )
183 SEMICOLON ;
184 RETURNSYM return
185 SEMICOLON ;
186 RBRACE }
187 RBRACE }
188 ELSESYM else
189 LBRACE {
190 PRINTFSYM printf
191 LPARENT (
192 DOUQUOTE "
193 STRING not > 0
194 DOUQUOTE "
195 RPARENT )
196 SEMICOLON ;
197 RBRACE }
198 RBRACE }
199 VOIDSYM void
200 ID funcPrint
201 LPARENT (
202 RPARENT )
203 LBRACE {
204 PRINTFSYM printf
205 LPARENT (
206 DOUQUOTE "
207 STRING  !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}
208 DOUQUOTE "
209 RPARENT )
210 SEMICOLON ;
211 PRINTFSYM printf
212 LPARENT (
213 ID constInt1
214 PLUS +
215 ID constInt2
216 RPARENT )
217 SEMICOLON ;
218 PRINTFSYM printf
219 LPARENT (
220 DOUQUOTE "
221 STRING %c
222 DOUQUOTE "
223 COMMA ,
224 ID constChar1
225 RPARENT )
226 SEMICOLON ;
227 RBRACE }
228 VOIDSYM void
229 ID funcDoWhileAndFor
230 LPARENT (
231 RPARENT )
232 LBRACE {
233 INTSYM int
234 ID i
235 SEMICOLON ;
236 INTSYM int
237 ID j
238 SEMICOLON ;
239 ID i
240 ASSIGN =
241 UNSIGNEDINT 0
242 SEMICOLON ;
243 ID j
244 ASSIGN =
245 UNSIGNEDINT 0
246 SEMICOLON ;
247 DOSYM do
248 LBRACE {
249 ID variableIntArray
250 LBRACK [
251 ID i
252 RBRACK ]
253 ASSIGN =
254 ID i
255 SEMICOLON ;
256 ID i
257 ASSIGN =
258 ID i
259 PLUS +
260 UNSIGNEDINT 1
261 SEMICOLON ;
262 RBRACE }
263 WHILESYM while
264 LPARENT (
265 ID i
266 LESS <
267 ID constInt3
268 RPARENT )
269 SEMICOLON ;
270 FORSYM for
271 LPARENT (
272 ID i
273 ASSIGN =
274 UNSIGNEDINT 0
275 SEMICOLON ;
276 ID i
277 LESS <
278 UNSIGNEDINT 10
279 SEMICOLON ;
280 ID i
281 ASSIGN =
282 ID i
283 PLUS +
284 UNSIGNEDINT 1
285 RPARENT )
286 LBRACE {
287 FORSYM for
288 LPARENT (
289 ID j
290 ASSIGN =
291 UNSIGNEDINT 0
292 SEMICOLON ;
293 ID j
294 LESS <
295 ID i
296 SEMICOLON ;
297 ID j
298 ASSIGN =
299 ID j
300 PLUS +
301 UNSIGNEDINT 1
302 RPARENT )
303 LBRACE {
304 PRINTFSYM printf
305 LPARENT (
306 ID variableIntArray
307 LBRACK [
308 ID i
309 RBRACK ]
310 RPARENT )
311 SEMICOLON ;
312 RBRACE }
313 RBRACE }
314 RBRACE }
315 INTSYM int
316 ID funcRecursion
317 LPARENT (
318 INTSYM int
319 ID n
320 RPARENT )
321 LBRACE {
322 IFSYM if
323 LPARENT (
324 ID n
325 LESSEQU <=
326 UNSIGNEDINT 0
327 RPARENT )
328 LBRACE {
329 PRINTFSYM printf
330 LPARENT (
331 DOUQUOTE "
332 STRING n cannot be smaller or equal than 0!
333 DOUQUOTE "
334 RPARENT )
335 SEMICOLON ;
336 RETURNSYM return
337 LPARENT (
338 MINUS -
339 UNSIGNEDINT 1
340 RPARENT )
341 SEMICOLON ;
342 RBRACE }
343 IFSYM if
344 LPARENT (
345 ID n
346 EQUAL ==
347 UNSIGNEDINT 1
348 RPARENT )
349 RETURNSYM return
350 LPARENT (
351 UNSIGNEDINT 1
352 RPARENT )
353 SEMICOLON ;
354 IFSYM if
355 LPARENT (
356 ID n
357 EQUAL ==
358 UNSIGNEDINT 2
359 RPARENT )
360 RETURNSYM return
361 LPARENT (
362 UNSIGNEDINT 1
363 RPARENT )
364 SEMICOLON ;
365 RETURNSYM return
366 LPARENT (
367 ID funcRecursion
368 LPARENT (
369 ID n
370 MINUS -
371 UNSIGNEDINT 1
372 RPARENT )
373 PLUS +
374 ID funcRecursion
375 LPARENT (
376 ID n
377 MINUS -
378 UNSIGNEDINT 2
379 RPARENT )
380 RPARENT )
381 SEMICOLON ;
382 RBRACE }
383 INTSYM int
384 ID multiParaFunc
385 LPARENT (
386 INTSYM int
387 ID a
388 COMMA ,
389 INTSYM int
390 ID b
391 COMMA ,
392 CHARSYM char
393 ID c
394 COMMA ,
395 CHARSYM char
396 ID d
397 COMMA ,
398 INTSYM int
399 ID e
400 COMMA ,
401 CHARSYM char
402 ID f
403 RPARENT )
404 LBRACE {
405 RETURNSYM return
406 LPARENT (
407 ID a
408 MULTI *
409 ID b
410 PLUS +
411 LPARENT (
412 ID c
413 MINUS -
414 ID d
415 RPARENT )
416 MINUS -
417 ID e
418 PLUS +
419 LPARENT (
420 ID b
421 divide /
422 ID f
423 RPARENT )
424 RPARENT )
425 SEMICOLON ;
426 RBRACE }
427 INTSYM int
428 ID MULTIpARAfUNC
429 LPARENT (
430 INTSYM int
431 ID a
432 COMMA ,
433 INTSYM int
434 ID b
435 RPARENT )
436 LBRACE {
437 RETURNSYM return
438 LPARENT (
439 ID a
440 MULTI *
441 ID b
442 MINUS -
443 UNSIGNEDINT 10
444 PLUS +
445 LPARENT (
446 ID a
447 divide /
448 ID b
449 RPARENT )
450 RPARENT )
451 SEMICOLON ;
452 RBRACE }
453 VOIDSYM void
454 MAINSYM main
455 LPARENT (
456 RPARENT )
457 LBRACE {
458 INTSYM int
459 ID tempInt
460 SEMICOLON ;
461 CHARSYM char
462 ID tempChar
463 SEMICOLON ;
464 INTSYM int
465 ID hJy
466 SEMICOLON ;
467 INTSYM int
468 ID HjY
469 SEMICOLON ;
470 ID hJy
471 ASSIGN =
472 UNSIGNEDINT 7
473 SEMICOLON ;
474 ID HjY
475 ASSIGN =
476 UNSIGNEDINT 17
477 SEMICOLON ;
478 PRINTFSYM printf
479 LPARENT (
480 ID MULTIpARAfUNC
481 LPARENT (
482 ID hJy
483 COMMA ,
484 ID HjY
485 RPARENT )
486 RPARENT )
487 SEMICOLON ;
488 SCANFSYM scanf
489 LPARENT (
490 ID variableInt1
491 COMMA ,
492 ID variableInt2
493 COMMA ,
494 ID variableChar1
495 RPARENT )
496 SEMICOLON ;
497 PRINTFSYM printf
498 LPARENT (
499 DOUQUOTE "
500 STRING \\n\\\\n\\\\\\n
501 DOUQUOTE "
502 COMMA ,
503 ID multiParaFunc
504 LPARENT (
505 UNSIGNEDINT 7
506 COMMA ,
507 UNSIGNEDINT 1
508 COMMA ,
509 QUOTE '
510 CHAR h
511 QUOTE '
512 COMMA ,
513 QUOTE '
514 CHAR j
515 QUOTE '
516 COMMA ,
517 UNSIGNEDINT 7
518 COMMA ,
519 QUOTE '
520 CHAR y
521 QUOTE '
522 RPARENT )
523 RPARENT )
524 SEMICOLON ;
525 ID variableCharArray
526 LBRACK [
527 UNSIGNEDINT 0
528 RBRACK ]
529 ASSIGN =
530 QUOTE '
531 CHAR z
532 QUOTE '
533 SEMICOLON ;
534 IFSYM if
535 LPARENT (
536 ID variableInt1
537 EQUAL ==
538 ID variableInt2
539 RPARENT )
540 LBRACE {
541 ID tempInt
542 ASSIGN =
543 ID funcReturnInt
544 LPARENT (
545 ID variableInt1
546 COMMA ,
547 ID variableInt1
548 RPARENT )
549 SEMICOLON ;
550 PRINTFSYM printf
551 LPARENT (
552 ID tempInt
553 RPARENT )
554 SEMICOLON ;
555 RBRACE }
556 IFSYM if
557 LPARENT (
558 ID variableInt1
559 GREAT >
560 ID variableInt2
561 RPARENT )
562 LBRACE {
563 ID tempChar
564 ASSIGN =
565 ID funcReturnChar
566 LPARENT (
567 ID variableChar1
568 RPARENT )
569 SEMICOLON ;
570 PRINTFSYM printf
571 LPARENT (
572 ID tempChar
573 RPARENT )
574 SEMICOLON ;
575 PRINTFSYM printf
576 LPARENT (
577 ID funcReturnChar
578 LPARENT (
579 QUOTE '
580 CHAR d
581 QUOTE '
582 RPARENT )
583 PLUS +
584 UNSIGNEDINT 1
585 RPARENT )
586 SEMICOLON ;
587 RBRACE }
588 IFSYM if
589 LPARENT (
590 ID variableChar1
591 EQUAL ==
592 ID constChar1
593 RPARENT )
594 LBRACE {
595 ID funcRelation
596 LPARENT (
597 ID variableInt1
598 RPARENT )
599 SEMICOLON ;
600 RBRACE }
601 IFSYM if
602 LPARENT (
603 ID variableChar1
604 EQUAL ==
605 ID constChar2
606 RPARENT )
607 LBRACE {
608 ID funcPrint
609 LPARENT (
610 RPARENT )
611 SEMICOLON ;
612 RBRACE }
613 IFSYM if
614 LPARENT (
615 ID variableChar1
616 EQUAL ==
617 ID constChar3
618 RPARENT )
619 LBRACE {
620 ID funcDoWhileAndFor
621 LPARENT (
622 RPARENT )
623 SEMICOLON ;
624 RBRACE }
625 IFSYM if
626 LPARENT (
627 ID variableChar1
628 EQUAL ==
629 ID variableCharArray
630 LBRACK [
631 UNSIGNEDINT 0
632 RBRACK ]
633 RPARENT )
634 LBRACE {
635 PRINTFSYM printf
636 LPARENT (
637 ID funcRecursion
638 LPARENT (
639 ID variableInt1
640 RPARENT )
641 RPARENT )
642 SEMICOLON ;
643 RBRACE }
644 RBRACE }
