1 CONSTSYM const
2 INTSYM int
3 ID constInt1
4 ASSIGN =
5 PLUS +
6 UNSIGNEDINT 7
7 COMMA ,
8 ID constInt2
9 ASSIGN =
10 MINUS -
11 UNSIGNEDINT 17
12 COMMA ,
13 ID constInt3
14 ASSIGN =
15 UNSIGNEDINT 10
16 SEMICOLON ;
17 CONSTSYM const
18 CHARSYM char
19 ID constChar1
20 ASSIGN =
21 QUOTE '
22 CHAR a
23 QUOTE '
24 COMMA ,
25 ID constChar2
26 ASSIGN =
27 QUOTE '
28 CHAR -
29 QUOTE '
30 COMMA ,
31 ID constChar3
32 ASSIGN =
33 QUOTE '
34 CHAR /
35 QUOTE '
36 SEMICOLON ;
37 INTSYM int
38 ID variableInt1
39 COMMA ,
40 ID variableInt2
41 COMMA ,
42 ID variableIntArray
43 LBRACK [
44 UNSIGNEDINT 10
45 RBRACK ]
46 SEMICOLON ;
47 CHARSYM char
48 ID variableChar1
49 COMMA ,
50 ID variableCharArray
51 LBRACK [
52 UNSIGNEDINT 1
53 RBRACK ]
54 SEMICOLON ;
55 INTSYM int
56 ID funcReturnInt
57 LPARENT (
58 INTSYM int
59 ID a
60 COMMA ,
61 INTSYM int
62 ID b
63 RPARENT )
64 LBRACE {
65 INTSYM int
66 ID c
67 SEMICOLON ;
68 ID c
69 ASSIGN =
70 MINUS -
71 ID a
72 PLUS +
73 ID b
74 PLUS +
75 UNSIGNEDINT 1
76 MULTI *
77 UNSIGNEDINT 2
78 SEMICOLON ;
79 RETURNSYM return
80 LPARENT (
81 ID c
82 RPARENT )
83 SEMICOLON ;
84 RBRACE }
85 CHARSYM char
86 ID funcReturnChar
87 LPARENT (
88 CHARSYM char
89 ID c
90 RPARENT )
91 LBRACE {
92 CHARSYM char
93 ID d
94 SEMICOLON ;
95 ID d
96 ASSIGN =
97 ID c
98 SEMICOLON ;
99 RETURNSYM return
100 LPARENT (
101 ID d
102 RPARENT )
103 SEMICOLON ;
104 RBRACE }
105 VOIDSYM void
106 ID funcRelation
107 LPARENT (
108 INTSYM int
109 ID n
110 RPARENT )
111 LBRACE {
112 IFSYM if
113 LPARENT (
114 ID n
115 GREAT >
116 UNSIGNEDINT 0
117 RPARENT )
118 LBRACE {
119 IFSYM if
120 LPARENT (
121 ID n
122 LESS <
123 UNSIGNEDINT 7
124 RPARENT )
125 LBRACE {
126 PRINTFSYM printf
127 LPARENT (
128 DOUQUOTE "
129 STRING <
130 DOUQUOTE "
131 RPARENT )
132 SEMICOLON ;
133 RETURNSYM return
134 SEMICOLON ;
135 RBRACE }
136 IFSYM if
137 LPARENT (
138 ID n
139 LESSEQU <=
140 UNSIGNEDINT 7
141 RPARENT )
142 LBRACE {
143 PRINTFSYM printf
144 LPARENT (
145 DOUQUOTE "
146 STRING <=
147 DOUQUOTE "
148 RPARENT )
149 SEMICOLON ;
150 RETURNSYM return
151 SEMICOLON ;
152 RBRACE }
153 IFSYM if
154 LPARENT (
155 ID n
156 EQUAL ==
157 UNSIGNEDINT 17
158 RPARENT )
159 LBRACE {
160 PRINTFSYM printf
161 LPARENT (
162 DOUQUOTE "
163 STRING ==
164 DOUQUOTE "
165 RPARENT )
166 SEMICOLON ;
167 RETURNSYM return
168 SEMICOLON ;
169 RBRACE }
170 IFSYM if
171 LPARENT (
172 ID n
173 GREATEQU >=
174 UNSIGNEDINT 77
175 RPARENT )
176 LBRACE {
177 PRINTFSYM printf
178 LPARENT (
179 DOUQUOTE "
180 STRING >=
181 DOUQUOTE "
182 RPARENT )
183 SEMICOLON ;
184 RETURNSYM return
185 SEMICOLON ;
186 RBRACE }
187 RBRACE }
188 ELSESYM else
189 LBRACE {
190 PRINTFSYM printf
191 LPARENT (
192 DOUQUOTE "
193 STRING not > 0
194 DOUQUOTE "
195 RPARENT )
196 SEMICOLON ;
197 RBRACE }
198 RBRACE }
199 VOIDSYM void
200 ID funcPrint
201 LPARENT (
202 RPARENT )
203 LBRACE {
204 PRINTFSYM printf
205 LPARENT (
206 DOUQUOTE "
207 STRING  !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}
208 DOUQUOTE "
209 RPARENT )
210 SEMICOLON ;
211 PRINTFSYM printf
212 LPARENT (
213 ID constInt1
214 PLUS +
215 ID constInt2
216 RPARENT )
217 SEMICOLON ;
218 PRINTFSYM printf
219 LPARENT (
220 DOUQUOTE "
221 STRING %c
222 DOUQUOTE "
223 COMMA ,
224 ID constChar1
225 RPARENT )
226 SEMICOLON ;
227 RBRACE }
228 VOIDSYM void
229 ID funcDoWhileAndFor
230 LPARENT (
231 RPARENT )
232 LBRACE {
233 INTSYM int
234 ID i
235 SEMICOLON ;
236 INTSYM int
237 ID j
238 SEMICOLON ;
239 ID i
240 ASSIGN =
241 UNSIGNEDINT 0
242 SEMICOLON ;
243 ID j
244 ASSIGN =
245 UNSIGNEDINT 0
246 SEMICOLON ;
247 DOSYM do
248 LBRACE {
249 ID variableIntArray
250 LBRACK [
251 ID i
252 RBRACK ]
253 ASSIGN =
254 ID i
255 SEMICOLON ;
256 ID i
257 ASSIGN =
258 ID i
259 PLUS +
260 UNSIGNEDINT 1
261 SEMICOLON ;
262 RBRACE }
263 WHILESYM while
264 LPARENT (
265 ID i
266 LESS <
267 ID constInt3
268 RPARENT )
269 SEMICOLON ;
270 FORSYM for
271 LPARENT (
272 ID i
273 ASSIGN =
274 UNSIGNEDINT 0
275 SEMICOLON ;
276 ID i
277 LESS <
278 UNSIGNEDINT 10
279 SEMICOLON ;
280 ID i
281 ASSIGN =
282 ID i
283 PLUS +
284 UNSIGNEDINT 1
285 RPARENT )
286 LBRACE {
287 FORSYM for
288 LPARENT (
289 ID j
290 ASSIGN =
291 UNSIGNEDINT 0
292 SEMICOLON ;
293 ID j
294 LESS <
295 ID i
296 SEMICOLON ;
297 ID j
298 ASSIGN =
299 ID j
300 PLUS +
301 UNSIGNEDINT 1
302 RPARENT )
303 LBRACE {
304 PRINTFSYM printf
305 LPARENT (
306 ID variableIntArray
307 LBRACK [
308 ID i
309 RBRACK ]
310 RPARENT )
311 SEMICOLON ;
312 RBRACE }
313 RBRACE }
314 RBRACE }
315 INTSYM int
316 ID funcRecursion
317 LPARENT (
318 INTSYM int
319 ID n
320 RPARENT )
321 LBRACE {
322 IFSYM if
323 LPARENT (
324 ID n
325 LESSEQU <=
326 UNSIGNEDINT 0
327 RPARENT )
328 LBRACE {
329 PRINTFSYM printf
330 LPARENT (
331 DOUQUOTE "
332 STRING n cannot be smaller or equal than 0!
333 DOUQUOTE "
334 RPARENT )
335 SEMICOLON ;
336 RETURNSYM return
337 LPARENT (
338 MINUS -
339 UNSIGNEDINT 1
340 RPARENT )
341 SEMICOLON ;
342 RBRACE }
343 IFSYM if
344 LPARENT (
345 ID n
346 EQUAL ==
347 UNSIGNEDINT 1
348 RPARENT )
349 RETURNSYM return
350 LPARENT (
351 UNSIGNEDINT 1
352 RPARENT )
353 SEMICOLON ;
354 IFSYM if
355 LPARENT (
356 ID n
357 EQUAL ==
358 UNSIGNEDINT 2
359 RPARENT )
360 RETURNSYM return
361 LPARENT (
362 UNSIGNEDINT 1
363 RPARENT )
364 SEMICOLON ;
365 RETURNSYM return
366 LPARENT (
367 ID funcRecursion
368 LPARENT (
369 ID n
370 MINUS -
371 UNSIGNEDINT 1
372 RPARENT )
373 PLUS +
374 ID funcRecursion
375 LPARENT (
376 ID n
377 MINUS -
378 UNSIGNEDINT 2
379 RPARENT )
380 RPARENT )
381 SEMICOLON ;
382 RBRACE }
383 INTSYM int
384 ID multiParaFunc
385 LPARENT (
386 INTSYM int
387 ID a
388 COMMA ,
389 INTSYM int
390 ID b
391 COMMA ,
392 CHARSYM char
393 ID c
394 COMMA ,
395 CHARSYM char
396 ID d
397 COMMA ,
398 INTSYM int
399 ID e
400 COMMA ,
401 CHARSYM char
402 ID f
403 RPARENT )
404 LBRACE {
405 RETURNSYM return
406 LPARENT (
407 ID a
408 MULTI *
409 ID b
410 PLUS +
411 LPARENT (
412 ID c
413 MINUS -
414 ID d
415 RPARENT )
416 MINUS -
417 ID e
418 PLUS +
419 LPARENT (
420 ID b
421 divide /
422 ID f
423 RPARENT )
424 RPARENT )
425 SEMICOLON ;
426 RBRACE }
427 VOIDSYM void
428 MAINSYM main
429 LPARENT (
430 RPARENT )
431 LBRACE {
432 INTSYM int
433 ID tempInt
434 SEMICOLON ;
435 CHARSYM char
436 ID tempChar
437 SEMICOLON ;
438 SCANFSYM scanf
439 LPARENT (
440 ID variableInt1
441 COMMA ,
442 ID variableInt2
443 COMMA ,
444 ID variableChar1
445 RPARENT )
446 SEMICOLON ;
447 PRINTFSYM printf
448 LPARENT (
449 DOUQUOTE "
450 STRING \\n\\\\n\\\\\\n
451 DOUQUOTE "
452 COMMA ,
453 ID multiParaFunc
454 LPARENT (
455 UNSIGNEDINT 7
456 COMMA ,
457 UNSIGNEDINT 1
458 COMMA ,
459 QUOTE '
460 CHAR h
461 QUOTE '
462 COMMA ,
463 QUOTE '
464 CHAR j
465 QUOTE '
466 COMMA ,
467 UNSIGNEDINT 7
468 COMMA ,
469 QUOTE '
470 CHAR y
471 QUOTE '
472 RPARENT )
473 RPARENT )
474 SEMICOLON ;
475 ID variableCharArray
476 LBRACK [
477 UNSIGNEDINT 0
478 RBRACK ]
479 ASSIGN =
480 QUOTE '
481 CHAR z
482 QUOTE '
483 SEMICOLON ;
484 IFSYM if
485 LPARENT (
486 ID variableInt1
487 EQUAL ==
488 ID variableInt2
489 RPARENT )
490 LBRACE {
491 ID tempInt
492 ASSIGN =
493 ID funcReturnInt
494 LPARENT (
495 ID variableInt1
496 COMMA ,
497 ID variableInt1
498 RPARENT )
499 SEMICOLON ;
500 PRINTFSYM printf
501 LPARENT (
502 ID tempInt
503 RPARENT )
504 SEMICOLON ;
505 RBRACE }
506 IFSYM if
507 LPARENT (
508 ID variableInt1
509 GREAT >
510 ID variableInt2
511 RPARENT )
512 LBRACE {
513 ID tempChar
514 ASSIGN =
515 ID funcReturnChar
516 LPARENT (
517 ID variableChar1
518 RPARENT )
519 SEMICOLON ;
520 PRINTFSYM printf
521 LPARENT (
522 ID tempChar
523 RPARENT )
524 SEMICOLON ;
525 RBRACE }
526 IFSYM if
527 LPARENT (
528 ID variableChar1
529 EQUAL ==
530 ID constChar1
531 RPARENT )
532 LBRACE {
533 ID funcRelation
534 LPARENT (
535 ID variableInt1
536 RPARENT )
537 SEMICOLON ;
538 RBRACE }
539 IFSYM if
540 LPARENT (
541 ID variableChar1
542 EQUAL ==
543 ID constChar2
544 RPARENT )
545 LBRACE {
546 ID funcPrint
547 LPARENT (
548 RPARENT )
549 SEMICOLON ;
550 RBRACE }
551 IFSYM if
552 LPARENT (
553 ID variableChar1
554 EQUAL ==
555 ID constChar3
556 RPARENT )
557 LBRACE {
558 ID funcDoWhileAndFor
559 LPARENT (
560 RPARENT )
561 SEMICOLON ;
562 RBRACE }
563 IFSYM if
564 LPARENT (
565 ID variableChar1
566 EQUAL ==
567 ID variableCharArray
568 LBRACK [
569 UNSIGNEDINT 0
570 RBRACK ]
571 RPARENT )
572 LBRACE {
573 PRINTFSYM printf
574 LPARENT (
575 ID funcRecursion
576 LPARENT (
577 ID variableInt1
578 RPARENT )
579 RPARENT )
580 SEMICOLON ;
581 RBRACE }
582 RBRACE }
